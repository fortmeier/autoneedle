#
# Copyright (C) 2014 Dirk Fortmeier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE

from sympy import *
from sympy.physics.mechanics import *
from sympy.printing import print_ccode
from sympy.utilities.codegen import codegen

from sympy.simplify.cse_main import *

import numpy
from sympy.utilities.iterables import * 

# vectors could be something like ["x", "y", "z"]
def sympyToC( symname, symfunc, vectors=[], scalars=[]):
	c_code = "// autogenerated function\n"

	# simplify the function
	tmpsyms = numbered_symbols("tmp")
	symbols, simple = cse(symfunc, symbols=tmpsyms)

	# create a list of used symbols
	symbolslist = map(lambda x:str(x), list(symfunc.atoms(Symbol)) )
	symbolslist.sort()

	varstring = ""
	if vectors == None:
		varstring=",".join( " Real "+x for x in symbolslist )
	else :
		varstring=",".join( " const Vector& "+s for s in vectors )
	
        if scalars != []:
		varstring+=","+",".join( " const Real& "+s for s in scalars )


	c_code += "Real "+str(symname)+"("+varstring+" )\n"
	c_code +=  "{\n"
	for s in symbols:
		#print s
		c_code +=  "  Real " +ccode(s[0]) + " = " + ccode(s[1]) + ";\n"
	c_code +=  "  Real r = " + ccode(simple[0])+";\n"
	c_code +=  "  return r;\n"
	c_code += "}\n\n"
	return c_code

def sympyToCMulti( functions, vectors, scalars, prefix = "" ):
	code = ""
	for name, symbol in functions:
		code +=sympyToC( prefix+name, symbol, vectors, scalars )
	return code



def sympyMatrixAdderNamed(funcname, funcMat, vectors, scalars, matrixname ): 
	c_code = "// autogenerated function\n"

	varstring=",".join( " const Vector& "+s for s in vectors )
	callstring=",".join( " "+s for s in vectors )

        if scalars != []:
		varstring+=", "+",".join( " const Real& "+s for s in scalars )
		callstring+=", "+",".join( " "+s for s in scalars )

	varstring = "int oX, int oY, "+matrixname+"& M, " + varstring

	c_code += "Real "+str(funcname)+"MatrixAdd("+varstring+" )\n"
	c_code +=  "{\n"

        for i in range(0,3):
          for j in range(0,3):
            c_code += "  M(oX+"+str(i)+", oY+"+str(j)+") += "
            c_code += funcMat[j][i]+"("+callstring+");\n"


	c_code += "}\n\n"
	return c_code

def sympyMatrixAdder(funcname, funcMat, vectors, scalars, matrixname=["Matrix", "SparseDiagonalMatrix"]): 
	c_code = ""
	for m in matrixname:
		c_code += sympyMatrixAdderNamed(funcname, funcMat, vectors, scalars, m ) 
	return c_code
